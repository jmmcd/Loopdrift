"""
\begin{abstract}

We present a method to generate sequences of
musical chords from the triadic tonnetz
using quantum walks. Considering the 
triadic tonnetz as a bipartite graph with
24 nodes, of degree 3, our walk moves 
between neighboring chords on the graph
(that always differ in just one note).
Given the degree 3 nature of the associated
graph, it lends itself naturally to a 
quantum walk using a three state quantum 
system (or qutrit). Up to permutations, 
we match each of these 3 quantum states to
the changes in the 3 notes of the triad
(moving either from major to minor, or 
vice versa). This corresponds exactly to 
the Parallel, Relative and Leittonwechsel
moves in Neo-Riemannian theory.
 We show that our quantum 
algorithm generates chord sequences that 
differ from those generated by classical 
random walks. All our code is freely 
available on github.

\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Classical/Quantum Algorithm (Overview)}

The triadic tonnetz is, mathematically 
speaking, a graph with the following 
properties:
\begin{itemize}
    \item 24 nodes
    (each representing a triad)
    \item each node is degree 3
    \item two vertices of the graph are
    connected by an edge if and only if 
    the corresponding chords differ by 
    exactly one note
    \item the graph is bipartite: One can
    split the 24 nodes in to the two sets 
    $S_M$ of 12 major chords and $S_m$ of
    12 minor chords
\end{itemize}

We chose for our unitary matrix, which 
operates on our 3-component spin system,
the \emph{Grover Coin}

\begin{equation}
    G = \frac{1}{3}
    \begin{pmatrix}
        -1 & 2 & 2\\
        2 & -1 & 2\\
        2 & 2 & -1
    \end{pmatrix}
\end{equation}
and we label our spin states as
\begin{equation}
\ket{\uparrow} \equiv
\begin{pmatrix}
1\\
0\\
0
\end{pmatrix},
\hspace{2cm}
\ket{\rightarrow} \equiv
\begin{pmatrix}
0\\
1\\
0
\end{pmatrix},
\hspace{2cm}
\ket{\downarrow} \equiv
\begin{pmatrix}
0\\
0\\
1
\end{pmatrix}
\end{equation}

Without loss of generality, we assign
\begin{itemize}
    \item $\ket{\uparrow}$ to a change in 
    the root of the triad, a 
    \emph{Leittonwechsel} move. For example, the
    major triad $[C,E,G]$ becomes the
    minor second inversion $[B,E,G]$.
    \item $\ket{\rightarrow}$ to a change in 
    the middle note of the triad, a 
    \emph{Parallel} move. For example, the
    major triad $[C,E,G]$ becomes the 
    minor $[C,E\flat,G]$.   
    \item $\ket{\downarrow}$ to a change in 
    the last note of the triad, a 
    \emph{Relative} move. For example, the
    major triad $[C,E,G]$ becomes the 
    minor first inversion $[C,E,A]$.   
\end{itemize}
In what follows, we identify triads simply by
their root note. For minor triads, we 
subscript
$m$, so that for example $C$ stands for the
major triad $[C,E,G]$ while 
$C_m$ stands for the
minor triad $[C,E\flat,G]$.
Our algorithm proceeds as follows:

\begin{description}
    \item[Step A] Pick an initial triad and 
    spin state, for example $
    \psi(0) = \ket{C,\uparrow}$
    \item[Step B1] Operate on the spin 
    state with our coin $G$:
\begin{equation}
    G = \frac{1}{3}
    \begin{pmatrix}
        -1 & 2 & 2\\
        2 & -1 & 2\\
        2 & 2 & -1
    \end{pmatrix}
    \begin{pmatrix}
        1\\
        0\\
        0
    \end{pmatrix}
    =
    \frac{1}{3}
    \begin{pmatrix}
        -1\\
        2\\
        2
    \end{pmatrix} 
\end{equation}
so that our state becomes 
\begin{equation}
\psi' = 
\frac{-1}{3}\ket{C,\uparrow}
+
\frac{2}{3}\ket{C,\rightarrow}
+
\frac{2}{3}\ket{C,\downarrow}
\end{equation}
    \item[Step B2] Shift  the 
    states according to the P/L/R 
    moves we defined, so that our 
    state becomes 
\begin{equation}
\psi(1) = 
\frac{-1}{3}\ket{E_m,\uparrow}
+
\frac{2}{3}\ket{C_m,\rightarrow}
+
\frac{2}{3}\ket{A_m,\downarrow}
\end{equation}

\end{description}

We simply repeat steps {\bf B1} and {\bf B2}
to get succesive quantum states:
\begin{equation}
\begin{split}
&\psi(1) \longrightarrow \frac{-1}{3}
\left[
\frac{-1}{3}\ket{G,\uparrow}
+
\frac{2}{3}\ket{E,\rightarrow}
+
\frac{2}{3}\ket{C,\downarrow}
\right]\\
&
\frac{2}{3}
\left[
\frac{2}{3}\ket{E\flat,\uparrow}
+
\frac{-1}{3}\ket{C,\rightarrow}
+
\frac{2}{3}\ket{A\flat,\downarrow}
\right]
+
\frac{2}{3}
\left[
\frac{2}{3}\ket{C,\uparrow}
+
\frac{2}{3}\ket{A,\rightarrow}
+
\frac{-1}{3}\ket{F,\downarrow}
\right]\\
&\implies \psi(2) = 
\frac{1}{9}\ket{G,\uparrow}
+
\frac{-2}{9}\ket{E,\rightarrow}
+
\frac{-2}{9}\ket{C,\downarrow}
+
\frac{4}{9}\ket{E\flat,\uparrow}
+
\frac{-2}{9}\ket{C,\rightarrow}
+
\frac{4}{9}\ket{A\flat,\downarrow}
+
\frac{4}{9}\ket{C,\uparrow}\\
&\hspace{5cm}
+
\frac{4}{9}\ket{A,\rightarrow}
+
\frac{-2}{9}\ket{F,\downarrow}
\end{split}
\end{equation}

The probabilities derived from these 
quantum states procede as follows:

\begin{description}
\item[Time $t=0$]
Play $C$ major (probability 1)

\item[Time $t=1$]
Play $E_m$  (probability 1/9), or 
$C_m$ (probability 4/9), or 
$A_m$ (probability 4/9).

\item[Time $t=2$]
\begin{enumerate}
    \item
    If the previous chord was $E_m$ 
    then play (neighboring) major 
    chords $[G, E, C]$ in the ratio 
    $[1, 4, 24]$
    \item 
    If the previous chord was $C_m$ 
    then play (neighboring) major 
    chords $[E\flat, C, A\flat]$ in the ratio 
    $[16, 24, 16]$
    \item
    If the previous chord was $A_m$ 
    then play (neighboring) major 
    chords $[C, A, F]$ in the ratio 
    $[24, 16, 4]$
    
\end{enumerate}

\end{description}

(As an explanation - in this listing for ratios,
the number $24$ which appears for $C$ is 
coming from the 3 terms involving $C$ in 
the state $\psi(2)$, contributing 
$(-2)^2 + (-2)^2 + 4^2$ to the probability.)



\subsection{Classical Algorithm $C_1$}
Let
\begin{equation}
    P^C(i) \equiv \mbox{Probability vector/distribution at
    step $i$ for classical walk}
\end{equation}
which as usual is a vector with entries
$0\leq P^C_k(i)\leq 1$ with $\sum_kP^C_k(i) = 1$
Let
\begin{equation}
    P^{CS}(i)
\end{equation}
be a sampling from $P^C(i)$, which will correspond to a 
specific note: It is a vector with a single 1 in some position
and zeroes elsewhere. For example,
$[0,0.3,0,0.7,0,0,0,0,0,0,0,0]$ has exactly two samplings,
either $[0,1,0,0,0,0,0,0,0,0,0,0]$  or 
$[0,0,0,1,0,0,0,0,0,0,0,0]$. Let our transition matrix for this
Markov Chain be $M$ (a $12\times 12$ matrix) so that
\begin{equation}
    P^C(i+1) = M P^C(i)
\end{equation}
We choose a positive integer $q>0$ and sample after each 
$q$ steps, for example in this table $q=4$ (shaded):


\begin{tabular}{||c|l|l||} 
\multicolumn{3}{c}{\bf\large Classical 
Algorithm $C_1$}\\
 \hline\hline
 {\bf Step:} &
 {\bf Probability Vector / Example} & {\bf Sampling / Example}\\ 
  \hline\hline
  \rowcolor{lightgray}
0 & \parbox{2cm}{$P^{C_1}(0) $\\ $[1,0,0,0,0,0,0,0,0,0,0,0]$ }&
\parbox{5cm}{$P^{{C_1}S}(0) $\\
$[1,0,0,0,0,0,0,0,0,0,0,0]$}
\\
\hline
1 & 
\parbox{5cm}{$P^{C_1}(1) = MP^{C_1}(0)$ \\
 $ \frac{1}{2}[0,1,0,0,0,0,0,0,0,0,0,1]$}
 & %P^{{C_1}S}(1)
\\
\hline
2 & 
\parbox{6cm}{$P^{C_1}(2) = M^2P^{C_1}(0)$\\
 $ \frac{1}{4}[2,0,1,0,0,0,0,0,0,0,1,0]$}
& % P^{{C_1}S}(2)
\\
\hline
3 & 
\parbox{6cm}{$P^{C_1}(3)  = M^3P^{C_1}(0) $\\
 $ \frac{1}{8}[0,3,0,1,0,0,0,0,0,1,0,3]$}
& % P^{{C_1}S}(3)
\\
\hline
\rowcolor{lightgray}
4 & 
\parbox{6cm}{$P^{C_1}(4) = M^4P^{C_1}(0)$\\
 $ \frac{1}{16} [6,0,4,0,1,0,0,0,1,0,4,0]$}
& 
\parbox{6cm}{$P^{{C_1}S}(4)$\\
 $ [0,0,1,0,0,0,0,0,0,0,0,0]$}
\\
\hline
5 & 
\parbox{6cm}{$P^{C_1}(5) = M^5P^{C_1}(0)$\\
 $ \frac{1}{32}[0,10,0,5,0,1,0,1,0,5,0,10]$}
& %P^{{C_1}S}(5)
\\
\hline
6 &
\parbox{6cm}{$P^{C_1}(6) = M^6P^{C_1}(0)$\\
 $ \frac{1}{64}[20,0,15,0,6,0,2,0,6,0,15,0]$}
& %P^{{C_1}S}(6)
\\
\hline
7 & P^{C_1}(7)  = M^7P^{C_1}(0)& %P^{{C_1}S}(7)
\\
\hline
\rowcolor{lightgray}
8 & P^{C_1}(8) = M^8P^{C_1}(0) & P^{{C_1}S}(8)\\
\hline
9 & P^{C_1}(9) = M^9P^{C_1}(0) & %P^{{C_1}S}(9)
\\
\hline
10 & P^{C_1}(10) = M^{10}P^{C_1}(0) &% P^{{C_1}S}(10)
\\
\hline
11 & P^{C_1}(11)  = M^{11}P^{C_1}(0) & %P^{{C_1}S}(11)
\\
\hline
\rowcolor{lightgray}
12& P^{C_1}(12) = M^{12}P^{C_1}(0) & P^{{C_1}S}(12)\\
\hline
13 & P^{C_1}(13)  = M^{13}P^{C_1}(0) & %P^{{C_1}S}(13)
\\
\hline
\vdots & \vdots & \vdots\\
 \hline\hline
\end{tabular}


\subsection{Classical Algorithm $C_2$}

\begin{center}
\begin{tabular}{||c|l|l||} 
\multicolumn{3}{c}{\bf\large Classical 
Algorithm $C_2$}\\
 \hline\hline
 {\bf Step:} & {\bf Probability Vector:} & {\bf Sampling:}\\ 
  \hline\hline
  \rowcolor{lightgray}
0 & \parbox{2cm}{$P^{C_2}(0) $\\ $[1,0,0,0,0,0,0,0,0,0,0,0]$ }&
\parbox{5cm}{$P^{{C_2}S}(0) $\\
$[1,0,0,0,0,0,0,0,0,0,0,0]$}
\\
\hline
1 & 
\parbox{5cm}{$P^{C_2}(1) = MP^{C_2}(0)$ \\
 $ \frac{1}{2}[0,1,0,0,0,0,0,0,0,0,0,1]$}
 & %P^{{C_1}S}(1)
\\
\hline
2 & 
\parbox{6cm}{$P^{C_2}(2) = M^2P^{C_2}(0)$\\
 $ \frac{1}{4}[2,0,1,0,0,0,0,0,0,0,1,0]$}
& % P^{{C_1}S}(2)
\\
\hline
3 & 
\parbox{6cm}{$P^{C_2}(3)  = M^3P^{C_2}(0) $\\
 $ \frac{1}{8}[0,3,0,1,0,0,0,0,0,1,0,3]$}
& % P^{{C_1}S}(3)
\\
\hline
\rowcolor{lightgray}
4 & 
\parbox{6cm}{$P^{C_2}(4) = M^4P^{C_2}(0)$\\
 $ \frac{1}{16} [6,0,4,0,1,0,0,0,1,0,4,0]$}
& 
\parbox{6cm}{$P^{{C_2}S}(4)$\\
 $ [0,0,1,0,0,0,0,0,0,0,0,0]$}
\\
\hline
5 & 
\parbox{6cm}{$P^{C_2}(5) = MP^{C_2S}(4)$\\
 $ \frac{1}{2}[0,1,0,1,0,0,0,0,0,0,0,0]$}
& %P^{{C_1}S}(5)
\\
\hline
6 &
\parbox{6cm}{$P^{C_2}(6) = M^2P^{C_2S}(4)$\\
 $ \frac{1}{4}[1,0,2,0,1,0,0,0,0,0,0,0]$}
& %P^{{C_1}S}(6)
\\
\hline
7 & P^{C_2}(7) = M^3P^{{C_2}S}(4) & %P^{{C_2}S}(7)
\\
\hline
\rowcolor{lightgray}
8 & P^{C_2}(8) = M^4P^{{C_2}S}(4) & P^{{C_2}S}(8)\\
\hline
9 & P^{C_2}(9) = MP^{{C_2}S}(8) &% P^{{C_2}S}(9)
\\
\hline
10 & P^{C_2}(10) = M^2P^{{C_2}S}(8) & %P^{{C_2}S}(10)
\\
\hline
11 & P^{C_2}(11) = M^3P^{{C_2}S}(8) & %P^{{C_2}S}(11)
\\
\hline
\rowcolor{lightgray}
12& P^{C_2}(12) = M^4P^{{C_2}S}(8) & P^{{C_2}S}(12)\\
\hline
13 & P^{C_2}(13) = MP^{{C_2}S}(12)  & %P^{{C_2}S}(13)
\\
\hline
\vdots & \vdots & \vdots\\
 \hline\hline
\end{tabular}
\end{center}

For classical algorithm $C_2$, we can see the difference 
(from classical algorithm $C_1$) in steps 5, 6 (and successive 
steps) in the tables, where the probability vectors differ
(and hence the samples in the last column 
will in general differ).

\subsection{Quantum Algorithm $Q_1$}

\begin{center}
\begin{tabular}{||c|c|c||} 
\multicolumn{3}{c}{\bf\large Quantum 
Algorithm $Q_1$}\\
 \hline\hline
 {\bf Step:} & {\bf Probability Vector:} & {\bf Sampling:}\\ 
  \hline\hline
  \rowcolor{lightgray}
0 & P^{Q_1}(0) & P^{{Q_1}S}(0)\\
\hline
1 & P^{Q_1}(1) = R(0,1)P^{Q_1}(0) 
&% P^{{Q_1}S}(1)
\\
\hline
2 & P^{Q_1}(2) = R(1,2)P^{Q_1}(1)
&% P^{{Q_1}S}(2)
\\
\hline
3 & P^{Q_1}(3) = R(2,3)P^{Q_1}(2) 
& %P^{{Q_1}S}(3)
\\
\hline
\rowcolor{lightgray}
4 & P^{Q_1}(4) = R(3,4)P^{Q_1}(3)
& P^{{Q_1}S}(4)\\
\hline
5 & P^{Q_1}(5) = R(0,1) P^{{Q_1}S}(4) & %P^{{Q_1}S}(5)
\\
\hline
6 & P^{Q_1}(6) = R(1,2) P^{Q_1}(5) 
& %P^{{Q_1}S}(6)
\\
\hline
7 & P^{Q_1}(7) = R(2,3) P^{Q_1}(6) 
& %P^{{Q_1}S}(7)
\\
\hline
\rowcolor{lightgray}
8 & P^{Q_1}(8)  = R(3,4) P^{Q_1}(7) & P^{{Q_1}S}(8)\\
\hline
9 & P^{Q_1}(9) = R(0,1) P^{{Q_1}S}(8) & %P^{{Q_1}S}(9)
\\
\hline
10 & P^{Q_1}(10)  = R(1,2) P^{{Q_1}}(9)
& %P^{{Q_1}S}(10)
\\
\hline
11 & P^{Q_1}(11) = R(2,3) P^{{Q_1}}(10)
& %P^{{Q_1}S}(11)
\\
\hline
\rowcolor{lightgray}
12& P^{Q_1}(12) = R(3,4) P^{{Q_1}}(11)
& P^{{Q_1}S}(12)\\
\hline
13 & P^{Q_1}(13) = R(0,1) P^{{Q_1}S}(12) & %P^{{Q_1}S}(13)
\\
\hline
\vdots & \vdots & \vdots\\
 \hline\hline
\end{tabular}
\end{center}

In our notation here, we omit completely
for now any reference to quantum states or
unitary matrices, instead just focusing on 
the resulting probability 
vectors/distributions. The matrices 
$R(i,j)$ are all distinct (which is the 
essential difference from the classical
case, where they are all the same ($M$)).
In this run displayed in the table, we 
\emph{reset} the quantum state after every 
$q=4$  steps.

\subsection{Quantum Algorithm $Q_2$}

\begin{center}
\begin{tabular}{||c|c|c||} 
\multicolumn{3}{c}{\bf\large Quantum 
Algorithm $Q_2$}\\
 \hline\hline
 {\bf Step:} & {\bf Probability Vector:} & {\bf Sampling:}\\ 
  \hline\hline
  \rowcolor{lightgray}
0 & P^{Q_2}(0) & P^{{Q_2}S}(0)\\
\hline
1 & P^{Q_2}(1) = R(0,1)P^{Q_2}(0) 
&% P^{{Q_2}S}(1)
\\
\hline
2 & P^{Q_2}(2) = R(1,2)P^{Q_2}(1)
&% P^{{Q_2}S}(2)
\\
\hline
3 & P^{Q_2}(3) = R(2,3)P^{Q_2}(2) 
&% P^{{Q_2}S}(3)
\\
\hline
\rowcolor{lightgray}
4 & P^{Q_2}(4) = R(3,4)P^{Q_2}(3)
& P^{{Q_2}S}(4)\\
\hline
5 & P^{Q_2}(5) = R(4,5) P^{{Q_2}}(4) & %P^{{Q_1}S}(5)
\\
\hline
6 & P^{Q_2}(6) = R(5,6) P^{Q_2}(5) 
& %P^{{Q_2}S}(6)
\\
\hline
7 & P^{Q_2}(7) = R(6,7) P^{Q_2}(7) 
& %P^{{Q_2}S}(7)
\\
\hline
\rowcolor{lightgray}
8 & P^{Q_2}(8)  = R(7,8) P^{Q_2}(7) & P^{{Q_2}S}(8)\\
\hline
9 & P^{Q_2}(9) = R(8,9) P^{{Q_2}}(8) & %P^{{Q_2}S}(9)
\\
\hline
10 & P^{Q_2}(10)  = R(9,10) P^{{Q_2}}(9)
& % P^{{Q_2}S}(10)
\\
\hline
11 & P^{Q_2}(11) = R(10,11) P^{{Q_2}}(10)
& %P^{{Q_2}S}(11)
\\
\hline
\rowcolor{lightgray}
12& P^{Q_2}(12) = R(11,12) P^{{Q_2}}(11)
& P^{{Q_2}S}(12)\\
\hline
13 & P^{Q_2}(13) = R(12,13) P^{{Q_2}}(12) & %P^{{Q_2}S}(13)
\\
\hline
\vdots & \vdots & \vdots\\
 \hline\hline
\end{tabular}
\end{center}

Again here, the matrices 
$R(i,j)$ are all distinct. In contrast to 
algorithm $Q_1$, we \emph{do not} collapse
the state after each $q$ steps. We 
sample the probability distribution after
each $q$ steps, but allow it to evolve 
further (it does not get reset). One 
can do this in practice by having multiple 
``experiments'': In the first you sample
at $q$ steps, in the second you sample at $2q$
steps, in the third at $3q$ steps, etc.

\begin{tikzpicture}[scale=2,every node/.style={circle,draw,minimum size=7mm,inner sep=1pt}]

\foreach \x in {0,1,2,3,4,5} {
    \foreach \y in {0,1,2,3} {
        \pgfmathtruncatemacro{\id}{\x + 6*\y} 
        \node (N\id) at (\x + 0.5*\y, -\y*0.866) {}; 
    }
}


\foreach \y in {0,1,2,3} {
    \foreach \x in {0,1,2,3,4} {
        \pgfmathtruncatemacro{\id}{\x + 6*\y}
        \pgfmathtruncatemacro{\rightNode}{\x+1 + 6*\y} 
        \draw (N\id) -- (N\rightNode);
        
        \ifnum\y<3
            \pgfmathtruncatemacro{\belowNode}{\x + 6*(\y+1)}  
            \pgfmathtruncatemacro{\belowRightNode}{\x+1 + 6*(\y+1)} 
            \draw (N\id) -- (N\belowNode);
            \draw (N\id) -- (N\belowRightNode);
        \fi
    }
}

\foreach \y in {0,1,2} {
    \foreach \x in {0,1,2,3,4} {
        \pgfmathtruncatemacro{\id}{\x + 6*\y}
        \pgfmathtruncatemacro{\rightNode}{\x+1 + 6*\y}
        \pgfmathtruncatemacro{\belowNode}{\x + 6*(\y+1)}
        \pgfmathtruncatemacro{\belowRightNode}{\x+1 + 6*(\y+1)}
        

        \filldraw[blue!20] (N\id.center) -- (N\rightNode.center) -- (N\belowNode.center) -- cycle;
        

        \filldraw[red!20] (N\rightNode.center) -- (N\belowRightNode.center) -- (N\belowNode.center) -- cycle;
    }
}

\def\pitches{{"C","C\textsuperscript{\#}","D","D\textsuperscript{\#}","E","F","F\textsuperscript{\#}","G","G\textsuperscript{\#}","A","{B\textsuperscript{\flat}}","B"}}

\foreach \y in {0,...,3} {
    \foreach \x in {0,...,5} {
        \pgfmathtruncatemacro{\id}{\x + 6*\y}
        \pgfmathtruncatemacro{\pitchIndex}{mod(7*\x + 4*\y,12)}
        \node at (N\id) {\pgfmathparse{\pitches[\pitchIndex]}\pgfmathresult};
    }
}

\end{tikzpicture}




\section*{Quantum Algorithm (Details)}

Some of the steps presented in the 
algorithm require further specification, 
which we now present.

\subsection*{ Step B details}


We have at our choice a number of quantities
to fix in each walk:
\begin{description}
    \item[Initial State] Each walk will 
    begin on one note (which we can 
    identify with a number in 
    $\mathbb{Z}_{12} = \{0,1,2,\dots 11\}$.
    However, this is not the full initial 
    state. We append the spin (qubit) 
    state to each note, giving 24 quantum
    basis states
    \begin{equation}
        \ket{j,\uparrow}, \hspace{1cm} 
        \ket{j,\downarrow}
        \hspace{2cm} (j\in\mathbb{Z}_{12}).
    \end{equation}
For a symmetric (1-dimensional) walk, 
we must chose initial spin state
\begin{equation}
    \frac{\ket{\uparrow} + i\ket{\downarrow}}{\sqrt{2}}
\end{equation}

    \item[Unitary  operation] The quantum 
    walk involves a unitary operation on 
    the spin state, followed by a 
    (conditional) shift left or right. 
    We chose the standard ``coin toss'' 
    operation given by the Hadamard 
    matrix
    \begin{equation}
        H = \frac{1}{\sqrt{2}}
        \begin{pmatrix}
        1 & 1\\
        1 & -1\\
        \end{pmatrix}
    \end{equation}
    \item[Length of walk]
    Let $p$ be the number of steps in 
    our quantum walk.
    To produce any quantum features (i.e.
    features that differ from a classical
    random process), we need at least 3 
    steps in our walk (this is the point 
    at which, for the first time,
    constructive and destructive 
    interference occur). As the walk 
    proceeds beyond 3 steps, it becomes 
    even ``more quantum'' (i.e. the 
    difference of the resulting probability
    distribution from a classical one is 
    greater). Thus, we can fine-tune the 
    amount of ``quantum-ness'' in our 
    algorithm by making $p$ longer.
\end{description}

We present some details of the quantum states in algorithms
$Q_1$ and $Q_2$ above.

\begin{center}
\begin{tabular}{||c|c|c||} 
\multicolumn{3}{c}{\bf\large Quantum States in
Algorithm $Q_1$}\\
 \hline\hline
 {\bf Step:} & {\bf Quantum State:} & {\bf Sampling:}\\ 
  \hline\hline
  \rowcolor{lightgray}
0 & \ket{0,\uparrow} & P^{{Q_1}S}(0)\\
\hline
1 & P^{Q_1}(1) = R(0,1)P^{Q_1}(0) 
&% P^{{Q_1}S}(1)
\\
\hline
2 & P^{Q_1}(2) = R(1,2)P^{Q_1}(1)
&% P^{{Q_1}S}(2)
\\
\hline
3 & P^{Q_1}(3) = R(2,3)P^{Q_1}(2) 
& %P^{{Q_1}S}(3)
\\
\hline
\rowcolor{lightgray}
4 & P^{Q_1}(4) = R(3,4)P^{Q_1}(3)
& P^{{Q_1}S}(4)\\
\hline
5 & P^{Q_1}(5) = R(0,1) P^{{Q_1}S}(4) & %P^{{Q_1}S}(5)
\\
\hline
6 & P^{Q_1}(6) = R(1,2) P^{Q_1}(5) 
& %P^{{Q_1}S}(6)
\\
\hline
7 & P^{Q_1}(7) = R(2,3) P^{Q_1}(6) 
& %P^{{Q_1}S}(7)
\\
\hline
\rowcolor{lightgray}
8 & P^{Q_1}(8)  = R(3,4) P^{Q_1}(7) & P^{{Q_1}S}(8)\\
\hline
9 & P^{Q_1}(9) = R(0,1) P^{{Q_1}S}(8) & %P^{{Q_1}S}(9)
\\
\hline
10 & P^{Q_1}(10)  = R(1,2) P^{{Q_1}}(9)
& %P^{{Q_1}S}(10)
\\
\hline
11 & P^{Q_1}(11) = R(2,3) P^{{Q_1}}(10)
& %P^{{Q_1}S}(11)
\\
\hline
\rowcolor{lightgray}
12& P^{Q_1}(12) = R(3,4) P^{{Q_1}}(11)
& P^{{Q_1}S}(12)\\
\hline
13 & P^{Q_1}(13) = R(0,1) P^{{Q_1}S}(12) & %P^{{Q_1}S}(13)
\\
\hline
\vdots & \vdots & \vdots\\
 \hline\hline
\end{tabular}
\end{center}


\subsection*{ Step C details}
Let us denote by $\ket{\psi}$ the final 
quantum state.
For each of the three walks, the 
probability of picking note 
$j\in \mathbb{Z}_{12} $ is 
\begin{equation}
    \left|\braket{\psi}{j,\uparrow}\right|^2
    +
    \abs{\braket{\psi}{j,\downarrow}}^2
\end{equation}

\subsection*{ Step D details}
We must chose a distance metric between 
chords. Let $n_k$ be the number of notes 
that the chord $CH_0'$ has in common with 
each of the neighbors of $CH_0$. Then 
$0\leq n_k\leq 3$ (and $k \in \{1,2,3\}$).
Choose (any) 
neighbor $k$ which has the property
that $n_k\geq n_l$ for all $l\neq k$.
(We say ``any'' here - since it is possible 
that two, or indeed all 3 of the $n's$
are the same, in which case we randomly 
pick one of the corresponding chords.)
"""